{{define "title"}}Quickstart @ hsecode{{end -}}

# Quickstart

{{if not .User -}}
[Sign in](signin) to open the page.
{{- else -}}

This tutorial goes through the whole process of implementing a part of stdlib and submitting the result. But first, a bit of a backstory...

## Generic Packages

Golang does not have [generic types](https://golang.org/doc/faq#generics). Long story short, all variables, function arguments, and struct fields must have concrete types. You cannot have a general-purpose function that adds any two numbers:
```go
func Add(x, y NumberLikeType) NumberLikeType { return x + y }
```

You would need to define the function for all possible types; also with different names since [function overloading](https://en.wikipedia.org/wiki/Function_overloading) is not a thing in Go:
```go
func AddUint8(x, y uint8)
func AddUint16(x, y uint16)
func AddUint32(x, y uint32)
func AddUint64(x, y uint64)
...
```

Sometimes Golang does *go* this way, look at the function names at [math/rand](https://golang.org/pkg/math/rand/#pkg-index). Other times it makes use of the [interfaces](https://tour.golang.org/methods/9) (see [sort package](https://golang.org/pkg/sort/#pkg-index)) to have somewhat generic behaviour. You can also use `interface{}` everywhere (which is a way to say "any type") but then you lose type safety and performance (all your values essentially become pointers).

This is rather unfortunate for this project. Most of the data structures and algorithms are type-agnostic. We want to implement our Herp-de-Derp algorithm once for all possible types, not for `int` or `uint8`.

That is why we use [genny](https://github.com/cheekybits/genny), a code generator. You are going to use generic types in your code and genny will automatically replace these generic types with concrete ones of your choice. The README has a [good example](https://github.com/cheekybits/genny#real-example) of such workflow.

Thanks to [go generate](https://github.com/cheekybits/genny#go-generate) integration you can write the rules of such replacement in comment-annotations and then run `go generate ./...` to apply them for all the files. You do not even need to do this manually: pre-commit can automatically run it for you before each commit (see [Prerequisites](../prerequisites)).

Typically, the test system will require you to autogenerate at least one version of your code for some concrete type (usually, `int`). Stdlib documentation helpfully provides the `//go:generate` annotations for that.

Packages with generic code will have the following file layout:

```
thingy/              // generic `thingy` package
|- thingy.go         // generic implementation of `thingy`
|- int/
|  |- dont_edit.go   // autogenerated version of thingy.go for ints
|- string/
|  |- dont_edit.go   // autogenerated version of thingy.go for strings
...
```

(*.go filenames can be different as long as they all have `package thingy` declaration.)

## First Package

We will start with the [hsecode.com/stdlib/cmp]({{url .DocsURL "/cmp/index.html"}}) package with two generic functions: `Min` and `Max`.

Initial file layout looks like this (check *[Subdirectories]({{.DocsURL}})* section in the docs):
```
cmp/
|- cmp.go
```

Create the file in a cloned copy of your working repository. A good start is to fill `cmp.go` with declarations from [the docs]({{url .DocsURL "/cmp/index.html"}}):

```go
package cmp

// good IDEs will put the import statement automatically
import "github.com/cheekybits/genny/generic"

type ValueType generic.Number

func Max(values ...ValueType) ValueType { }

func Min(values ...ValueType) ValueType { }
```

`Max` and `Min` are *[variadic](https://gobyexample.com/variadic-functions)* functions: they take any number of same-type arguments that are placed into the `values` slice (similar to `*args` in Python). `ValueType` is a generic type that `genny` will replace with other types of your choice. `int`-version is required for tests, so make sure to put the comment-annotation from docs anywhere in the file:

```go
//go:generate genny -in=$GOFILE -out=int/dont_edit.go gen "ValueType=int"
```

`genny` has two functionally equivalent generic types: `generic.Number` and `generic.Type`. The only reason we use `generic.Number` here is that it makes syntax checker happy: otherwise it will warn you that generic types cannot be compared with operators {{"`<`"| unescape}} and {{"`>`"| unescape}}.

The programming part of the package is fairly straightforward:

```
func Min(values ...ValueType) ValueType {
	m := values[0]
	for i := 1; i {{ "<"| unescape }} len(values); i++ {
		if values[i] {{ "<"| unescape }} m {
			m = values[i]
		}
	}
	return m
}
```

The `Max` function is done symmetrically. Do not forget to make the functions panic if there are no arguments as required by the docs: 

```
if len(values) == 0 {
    panic("at least one argument required")
}
```

## Before Submission

Now that your code is ready, you have to do a couple of more things before submitting it:

#### Generate `int`-version of your generic code
```
$ cd hsecode-stdlib
$ go generate ./...
```

New file `int/dont_edit.go` will be created.

#### Ensure that your code meets the stardard code style
```
$ gofmt -w -l 
```

The command will fix all formatting issues (if there are any) and print a list of changed files.

You can avoid running `go generate` and `gofmt` manually if you install pre-commit (see [Prerequisites](../prerequisites))


#### Add a test ID to `.stdlib.yaml`

The file tells the system which tests suites to run on your code. Check the list of IDs in the [Tests section](..). Note that they may not fully correspond to package names, e.g. if a test suite checks only a part of some package.

## Submission

Create a new commit in your working repository with all the resulting files. Push it to GitHub.

Your commit will be immediately enqueued in the test system. Check the GitHub [commit page](https://github.com/{{.User.Login}}/{{.User.Repo}}/commits/master) to the status of each commit:

![Commit page](/.static/commits.png)

Click the *Details* link to see the test results:

![Check page](/.static/check.png)

* `format` checks that the code meets the stardard code style
* `lint` checks syntactic restrictions, e.g. that only allowed packages are used
* `configure` reads `.stdlib.yaml` to determine which tests suites to run
* `build::*` compiles each tests suites
* `test::*` runs *unit* and *performance* tests from each suite

(Note that the results of `build::*` and `test::*` stages are cached: they will only run once for the same source code and will not be shown on the GitHub check page. If they are missing, click the *full report* link to see all the stages.)

**Unit tests** ensure that your code correctly implements the intended data structure or algorithms. Most of the time they compare returned values with the expected ones, but may also check other conditions, e.g. asymptotic memory requirements or that a function does not modify its input data.

**Performance tests** generally run your code multiple times on a relatively large random dataset and count how many CPU cycles it took. The number is compared to CPU cycles of the reference implementation (baseline). **The tests succeed if your code reaches 120% of the baseline or less.**

The source code of these tests is secret. Depending on the test, it may not be possible to give you a detailed feedback if your code fails on a particular input. `fmt.Print*` functions in your code are allowed, but will not take any effect during test execution. More often than not you will get something like "the function returned something weird, go figure why". This is the reason why you are encouraged to write your own unit tests

## Write Your Own Tests

Test files must be prefixed with  `_test.go` and are typically located in the package you are going to test. Their package declaration should also be prefixed with `_test`. You can safely commit the test files to the repository: the test system completely ignores them.

A simple unit-test written with a built-in [testing](https://golang.org/pkg/testing/) framework looks like this:

```go
// cmp/int/cmp_test.go:
package cmp_test

import (
  // imported package is renamed to avoid conflict with type `int`
  cmp "hsecode.com/stdlib/cmp/int"
  "testing"
)

func TestCompare(t *testing.T) {
  if cmp.Min(4, 3, 2, 0, 10) != 0 {
          t.Fatal("unexpected Min() value")
  }
  a := []int{4, 3, 2, 1}
  r := cmp.Max(a...)
  if r != 4 {
          t.Fatalf("Max(%v...) = %v, expected 4", a, r)
  }
}
```

The tests can be run from the terminal:

```
$ cd cmp/int
$ go test -v
=== RUN   Test__Compare
--- PASS: Test__Compare (0.00s)
PASS
ok  	hsecode.com/stdlib/cmp/int	0.001s
```

or from an IDE (*run package tests* in VS Code):

![running tests in vs code](/.static/run-tests.png)

In the latter case VS Code will highlight the test coverage of your source code:

![test coverage in vs code](/.static/coverage.png)

Same thing can be achieved in the terminal:

```
$ go test -coverprofile=cover.out
PASS
coverage: 78.6% of statements
ok  	hsecode.com/stdlib/cmp/int	0.001s

// will open an html-page with highlighted coverage
$ go tool cover -html=cover.out
```

You can either test generic packages (e.g. `cmp`) or their concrete versions (e.g. `cmp/int` as in the example above). In the latter case **be careful not to modify autogenerated files**: your changes will be lost with the next `go generate`.

{{end}}

* [Back to main page](..)
